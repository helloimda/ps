#include <iostream>
#include <cmath>
#include <vector>
#include <algorithm>

using namespace std;

// 10844 쉬운계단수
// 시작수 0을 제외하고 1~9까지 반복문 1일때 계단수 합 카운팅 2일때도 똑같이~   1~9를 카운팅하면 정답?
// n이 2일때 1~8까지는 2개 9는 98하나로 17개임
// n이 4일때까지 노가다로 숫자를 찾아보니 공통점을 발견
// n=1 일때 1 = 1
// n=2 일때 1 = 1 0, 1 2
// n=3 일때 1 = 1 0 1 , 1 2 1, 1 2 3
// n=4 일때 1 = 1 0 1 0, 1 0 1 2
//느낌으로 n-1번째에 있던 계단수가 2개로 증식되는거임 ㅇㅇ 2번째의 12는 3번째의 121,123으로 증가함 
//이걸 키포인트로 정하고 dp는 n번 for문을 통해 갯수를 세면 되는듯?


int main() {
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int v[101][10]={0,};
    
    int n,hap=0;
    cin >> n;

    for(int i=1; i<=9; i++){
        v[1][i]=1;
    }

    
    for(int i=2; i<=n; i++){
        for(int j=0; j<=9; j++){
            if (j==0){
                v[i][j]=v[i-1][j+1];
            }

            else if (j==9){
                v[i][j]=v[i-1][j-1];
            }
            else {
                v[i][j]=v[i-1][j-1]+v[i-1][j+1];
            }
            v[i][j]%=1000000000;
        }    
    }
        for(int i=0; i<=9; i++){
            hap =(hap+v[n][i])%1000000000;;
        }
        cout << hap;
}
//0트 0혹은9로 끝나는 꼭다리 수는 2개가아닌 1개씩 증가함 벡터에 갯수만 저장하려고했는데 숫자도 같이해야하는건지 의문임
//재귀로 해야하는건가 생각해보니 n번 반복으로는 갯수를 셀 수가없는듯?
//dfs문제같은데 cnt정해놓고 n일때까지 증식하기? 말이되나 좀 비효율적인듯

//그냥 배열에 숫자만 하는게 맞는듯 이전값을 불러와 더할 수 있도록 함 +-값의 2개합을 합한값

//1트 모듈러안했음
//2트 모둘러를 계속해줘야하는듯; 연산하는 모든부분에서 안하면 값이 너무커서 오버플로우 발생하고 값이 변하는듯?

