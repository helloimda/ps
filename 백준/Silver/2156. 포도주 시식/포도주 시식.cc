#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

//계단 오르기와 유시한 문제
//최대한 많이 마셔야 하며, 연속 3개를 마실 수 없다. 1 2번 마시고 4번 이던가 2,3번이던가 최댓값을 계속 정해줘야함 123 그냥 계단오르기랑 똑같아보이는데?
int main() {
    int n,tmp;
    cin >> n;
    vector<int> v(n+1);
    vector<int> dp(n+1); 
    for(int i=1; i<=n; i++){
        cin >> tmp;
        v[i]= tmp;
    }
    dp[1] = v[1];
    if(n>=2)dp[2] = dp[1]+v[2];
    //if(n>=3)dp[3] = max(dp[1]+v[3], v[2]+v[3]);
    if(n>=3) dp[3] = max({dp[2], v[1] + v[3], v[2] + v[3]});

    for(int i=4; i<=n;i++){
        //dp[i] = max(dp[i-3]+v[i-1]+v[i],dp[i-2]+v[i]);
        dp[i] = max({dp[i-1], dp[i-2] + v[i], dp[i-3] + v[i-1] + v[i]});
    }
    cout << max(dp[n], dp[n-1]);

}

//이문제의 제한조건은 계단오르기와 다르게 끝점이 존재하지않음 결국엔 n ~ n-1 둘중 하나이기 때문에 마지막 max를 사용해야함
//조건 다 맞췄는데 왜 틀리지 ㅅㅂ; 연속 3개 불가능, 끝점 존재하지 않음, 최댓값은 dp를 통해 구할 수 있음

//해결 --- 이문제는 계단오르기처럼 꼭 연속으로 먹지 않아도 됨 이게 무슨소리냐면 극단적으로 반례케이스를 보자면
/*6
100
100
1
1
100
100*/

// 3~4번째의 와인을 하나라도 마셔버리면 최댓값에 도달할 수 없음 그러므로 n-1번째 dp랑도 같이 비교를 해야함
// 처음 알게된 사실 max는 {}를 통해 인자값을 여러개로 증가시킬 수 있다.

// 6트 이문제는 계단 문제와 유사한 듯 보였지만 달랐음 안먹어도 된다는 조건이 있기에 모든 경우의수를 가정해야함 3c2 1+2, 1+3, 2+3의 조건을 전부 비교해야하는 문제 
